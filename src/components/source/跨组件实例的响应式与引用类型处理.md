##### 什么叫做跨组件实例的响应式？

Vue 的响应式

Vue 的响应式数据是指当数据发生变化时，相关依赖的视图会自动更新的一种机制，vue 通过 DefineProperty，劫持原始数据的 setter，getter，通过监听数据的变化完成响应式构建。

这种响应式一般是发生在 Vue 实例内部，即通过实例 vm 属性的变更，来更新 DOM；而在父子组件引用场景下，父组件的数据更新会影响子组件的更新，这种就是跨组件实例的响应式，比如 props.

1. 组件内部的响应式

如 data，computed，inject , 以 provide / inject 为例

-   provide / inject

> 在 Vue.js 中，当父组件通过 provide 提供响应式数据(基本数据类型)，而子组件通过 inject 接收并直接在模板中使用时，我们发现，父组件更新 provide 中的数据并不会触发子组件的重新渲染。

**当 provide 提供的是响应式引用类型对象-如 Object | Array 时，那么 父组件的更新，还是会触发子组件的更新 ！**

当我们初始化 inject 数据时，会递归从组件自己出发，一层一层向上递归查询最近的父组件中的 provide 数据，之后将 provide 对象上匹配到的 inject 对应的 属性 key，构建一个新的响应式对象，

这个响应式对象会绑定到组件实例上。关键的地方在于， 由 provide[key] 构建获得到 value 如果是一个引用类型对象，那么当对该 value 进行操作时，会触发响应式 setter，从而被动完成依赖收集,导

致父组件提供的数据变化时影响子组件重新渲染；只有当 provide[key] 得到的是一个基本类型，如 Number，那么新构建的 result[key] 就只是一个值复制操作。

```javascript
/** result 为从父组件上递归找到的 provide[key]的集合 */

defineReactive(vm, key, result[key])
```

2. 跨实例的响应式

-   props

vue 在子组件实例化的 props 初始化时，是通过获取父组件上构建的 propsData ，这个 propsData 则是父组件在解析和编译模板时，收集到的子组件的所有标签，之后在子组件的实例化阶段遍历该标签属性，

结合检查子组件的 props 配置，将对应的属性添加到 propsData 上，之后 Vue 对子组件 props 重新构造了响应式，由于 setter|getter 的机制，子组件的 watcher 会被对应响应式属性收集，当父组件变更对应

数据时，触发子组件的更新。

```javascript
// 构建响应式props
defineReactive(props, key, value)

// 将props的属性代理到vm上
if (!(key in vm)) {
    proxy(vm, `_props`, key)
}
```

3. 所以我们能看到，跨组件实例的响应式，是通过引用类型来产生的，本质上是因为 vue 对于数据的处理，没有用深拷贝处理对象上的每个属性，从而使得属性的 getter 操作机制发挥副作用。

那么，为什么 Vue 内部很少用深度遍历呢？

Vue 内部在处理响应式数据时，确实倾向于浅遍历而非深度遍历，这是因为深度遍历整个对象树可能会带来性能开销，并且在实际应用中，深度嵌套的对象结构并不常见。

Vue 的设计目标之一是追求高性能和简洁易用，因此在处理引用类型数据时选择了一些权衡。

-   性能考虑： 深度遍历整个对象树会耗费更多的时间，特别是在对象结构很大的情况下。Vue 的响应式系统通过追踪对象的引用关系来进行数据更新，这种浅遍历的方式在大多数情况下能够满足需求，并且更高效。

-   简化逻辑： 浅遍历可以更简单地实现，减少了复杂性。深度遍历可能需要更多的逻辑来处理各种特殊情况，例如循环引用等。

-   应用场景： 在实际应用中，大多数数据结构并不是深度嵌套的对象，而是较为扁平的数据结构。Vue 的设计更加倾向于满足这种常见的使用场景。

虽然 Vue 的响应式系统使用的是浅遍历，但 Vue 提供了 Vue.set 和 vm.$set 这样的方法来确保对于引用类型的数据，可以正确地触发视图更新。

这些方法实际上是通过在数据对象上添加一个特殊的标记（**__ob__**）来进行追踪的。

在使用 Vue 时，开发者可以使用 Vue.set 或 vm.$set 来处理引用类型数据的更新，以确保响应式系统能够正确地追踪这些变化，而无需进行深度遍历。

深度遍历的需求通常在特殊的嵌套数据结构下才会显得更为重要。
